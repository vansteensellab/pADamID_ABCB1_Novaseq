
# ts180228 - updated
# Changed from paired-end to single-end, and focused on DamID (meaning that all
# anti-duplicate steps are removed).

# Run with:
# source activate WASP
# export LD_LIBRARY_PATH="/home/t.v.schaik/mydata/miniconda3/envs/WASP/lib:$LD_LIBRARY_PATH"
#
# snakemake -s WASP_damid.snake --cores 14 --printshellcmds --use-conda


# configfile: "WASP_config.yaml"

import glob


# def read_samples():
#     """Function to get names and fastq paths from a sample file specified
#     in the configuration. Input file is expected to have 2 columns:
#     <unique_sample_id> <fastq_path>. Modify this function
#     as needed to provide a dictionary of sample_id keys and (fastq1)
#     values"""
#     f = open(config['sample_file'], "r")
#     samp_dict = {}
#     for line in f:
#         if line.startswith("#"):
#             continue
#         words = line.strip().split()
#         samp_dict[words[0]] = (words[1], )
#
#     return samp_dict

# def read_1kg_samples():
#     f = open(config['sample_file'], "r")
#     samp_dict = {}
#     for line in f:
#         words = line.strip().split()
#         samp_dict[words[1]] = words[0]
#
#     return samp_dict
#
# SAMP_TO_1KG = read_1kg_samples()

def get_chromosomes():
    """Gets list of chromosomes with from VCF files"""
    filenames = os.listdir(config['vcf_dir'])

    chr_names = set([])
    for filename in filenames:
        if filename.endswith(".vcf.gz"):
            m = re.match(".*(chr[0-9A-Z]+).*", filename)
            if m:
                chr_names.add(m.groups()[0])

    return chr_names
    
    
# rule all:
#     input:
#         expand(config['output_dir'] + "/split_sort/{basename}_{genome}.bam",
#                sample=read_samples().keys(),
#                genome = ["129S1", "CAS"])

##############################################################################
## Supporing rules
##


# First, map and sort the reads to the reference genome
rule map_bowtie2_single_end1:
    """map reads using bowtie2"""
    input:
        fastq = "%s/{basename}.fastq.gz" % out_parse
    params:
        output_dir = out_WASP
    output:
        temp(out_WASP + "/map1/{basename}.bam")
    conda:
        config["conda_mapping"]
    threads: 6
    shell:
        "mkdir -p {params.output_dir} ; "
        "mkdir -p {params.output_dir}/map1 ; "
        "{config[bowtie2]} -p {threads} --very-sensitive -x {config[bowtie2_index]} -U {input.fastq} "
        "| {config[samtools]} view -b -q 10 - > {output} "

rule sort_and_index_bam1:
    """sort and index bam generated by first mapping step"""
    input:
        out_WASP + "/map1/{basename}.bam"
    params:
        output_dir = out_map
    output:
        # temp(config["out_WASP"] + "/map1_sort/{basename}.bam"),
        # temp(config["out_WASP"] + "/map1_sort/{basename}.bam.bai")
        "%s/{basename}.bam" % out_map,
        "%s/{basename}.bam.bai" % out_map
    conda:
        config["conda_mapping"]
    shell:
        "mkdir -p {params.output_dir}; "
        "{config[samtools]} sort -o {output[0]} {input}; "
        "{config[samtools]} index {output[0]}"


# Then, get the mapped reads overlapping SNP locations and modify reads to remap
rule find_intersecting_snps_single_end:
    """find intersecting SNPs using WASP script"""
    input:
        bam="%s/{basename}.bam" % out_map,
    params:
        output_dir = out_WASP
    output:
        fastq = temp(out_WASP + "/find_intersecting_snps/{basename}.remap.fq.gz"),
        keep_bam = temp(out_WASP + "/find_intersecting_snps/{basename}.keep.bam"),
        remap_bam = temp(out_WASP + "/find_intersecting_snps/{basename}.to.remap.bam")
    log: 
        out_WASP + "/find_intersecting_snps/{basename}.log"
    conda:
        config["conda_WASP"]
    shell:
        "mkdir -p {params.output_dir}/find_intersecting_snps ; "
        "python {config[wasp_dir]}/mapping/find_intersecting_snps.py"
        "    --is_sorted"
        "    --output_dir {params.output_dir}/find_intersecting_snps"
        "    --snp_dir {config[snp_dir]}"
        #"    --samples {config[sample_file]} "
        "    {input.bam}"
        " 2> {log}"


# Remap and sort the newly designed reads
rule map_bowtie2_single_end2:
    """map reads a second time using bowtie2"""
    input:
        fastq = out_WASP + "/find_intersecting_snps/{basename}.remap.fq.gz",
        # fastq1=config['output_dir'] + "/find_intersecting_snps/{basename}.remap.fq1.gz",
        # fastq2=config['output_dir'] + "/find_intersecting_snps/{basename}.remap.fq2.gz"
    params:
        output_dir = out_WASP
    output:
        temp(out_WASP + "/map2/{basename}.bam")
    conda:
        config["conda_mapping"]
    threads: 6
    shell:
        "mkdir -p {params.output_dir}/map2 ; "
        # "{config[bowtie2]} -x {config[bowtie2_index]} -1 {input.fastq1} -2 {input.fastq2} "
        "{config[bowtie2]} -p {threads} --very-sensitive -x {config[bowtie2_index]} -U {input.fastq} "
        "| {config[samtools]} view -b -q 10 - > {output}"
        
rule sort_and_index_bam2:
    """sort and index bam generated by second mapping step"""
    input:
        out_WASP + "/map2/{basename}.bam"
    params:
        output_dir = out_WASP
    output:
        temp(out_WASP + "/map2_sort/{basename}.bam"),
        temp(out_WASP + "/map2_sort/{basename}.bam.bai")
    conda:
        config["conda_mapping"]
    shell:
        "mkdir -p {params.output_dir}/map2_sort ; "
        "{config[samtools]} sort -o {output[0]} {input} ; "
        "{config[samtools]} index {output[0]}"


# Filter reads to map on the same position, even with SNPs "mutated"
rule filter_remapped_reads:
    """filter reads from second mapping step"""
    input:
        to_remap_bam = out_WASP + "/find_intersecting_snps/{basename}.to.remap.bam",
        remap_bam = out_WASP + "/map2_sort/{basename}.bam",
    params:
         output_dir = out_WASP
    output:
        keep_bam = temp(out_WASP + "/filter_remapped_reads/{basename}.keep.bam")
    log: 
        out_WASP + "/filter_remapped_reads/{basename}.log"
    conda:
        config["conda_WASP"]
    shell:
        "mkdir -p {params.output_dir}/filter_remapped_reads ; "
        "python {config[wasp_dir]}/mapping/filter_remapped_reads.py"
        " {input.to_remap_bam} {input.remap_bam} {output.keep_bam}"
        " 2> {log}"


# Merge the two bams with the "good" reads
rule merge_bams:
    """merge 'keep' BAM files from mapping steps 1 and 2, then sort and index"""
    input:
        keep1 = out_WASP + "/find_intersecting_snps/{basename}.keep.bam",
        keep2 = out_WASP + "/filter_remapped_reads/{basename}.keep.bam"
    params:
         output_dir = out_WASP
    output:
        merge = temp(out_WASP + "/merge/{basename}.keep.merge.bam"),
        sort = temp(out_WASP + "/merge/{basename}.keep.merge.sort.bam"),
        index = temp(out_WASP + "/merge/{basename}.keep.merge.sort.bam.bai"),
    conda:
        config["conda_mapping"]
    shell:
        "mkdir -p {params.output_dir}/merge ; "
        "{config[samtools]} merge {output.merge} {input.keep1} {input.keep2}; "
        "{config[samtools]} sort -o {output.sort} {output.merge}; "
        "{config[samtools]} index {output.sort}"


# Split the resulting bam files into the two strains and sort / index the bams
rule split_bams:
    """Split bam files based on the SNPs"""
    input:
         bam = out_WASP + "/merge/{basename}.keep.merge.sort.bam",
    params:
         output_dir = out_WASP
    output:
        temp(out_WASP + "/split/{basename}_129S1.bam"),
        temp(out_WASP + "/split/{basename}_CAS.bam"),
        out_WASP + "/split/{basename}_stats.txt"
    conda:
        config["conda_WASP"]
    log: 
        out_WASP + "/split/{basename}.log"
    shell:
        "python {config[split_genomes]}"
        " {config[snp_dir]}"
        " {input.bam}"
        " 129S1,CAS"
        " {params.output_dir}/split"
        " 2> {log}"

rule sort_and_index_bam3:
    """sort and index bam generated by final splitting mapping step"""
    input:
        out_WASP + "/split/{basename}_{genome}.bam"
    params:
         output_dir = out_map_strainspecific
    output:
        out_map_strainspecific + "/{basename}_{genome}.bam",
        out_map_strainspecific + "/{basename}_{genome}.bam.bai"
    conda:
        config["conda_mapping"]
    shell:
        "mkdir -p {params.output_dir} ; "
        "{config[samtools]} sort -o {output[0]} {input} ; "
        "{config[samtools]} index {output[0]}"

